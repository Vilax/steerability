#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Sep 26 11:22:57 2019

@author: jlvilas
"""
import numpy as np
import numpy.matlib as npm
import random
import scipy as sp


# class tommyFunctions:
#     def __init__(self):
#         pass

# def distinguishable_colors(self, ncolors, backgrounds=[[0,0,0],[1,1,1]],
#                            save_csv=True, plot_colormap=True, verbose=True,
#                            out_dir='.'):
#
#     Create a colormap of perceptually distinguishable colors.
#     This program is a Python program based on Tim Holy's 2010-2011
#     BSD-licensed Matlab program "distinguishable_colors.m"
#     (https://www.mathworks.com/matlabcentral/fileexchange/
#      29702-generate-maximally-perceptually-distinct-colors):
#     "This function generates a set of colors which are distinguishable
#     by reference to the "Lab" color space, which more closely matches
#     human color perception than RGB. Given an initial large list of possible
#     RGB colors, it iteratively chooses the entry in the list that is farthest
#     (in Lab space) from all previously-chosen entries. While this "greedy"
#     algorithm does not yield a global maximum, it is simple and efficient.
#     Moreover, the sequence of colors is consistent no matter how many you
#     request, which facilitates the users' ability to learn the color order
#     and avoids major changes in the appearance of plots when adding or
#     removing lines."
#     Parameters
#     ----------
#     ncolors : integer
#         number of colors for the colormap
#     backgrounds : list of list(s) of 3 elements between 0 and 1
#         rgb background colors to initialize and distinguish from
#     save_csv : Boolean
#         save colormap as csv file?
#     plot_colormap : Boolean
#         plot colormap as horizontal bar chart?
#     verbose : Boolean
#         print to stdout?
#     Returns
#     -------
#     colors : numpy ndarray of ndarrays of 3 floats between 0 and 1
#         rgb colormap
#     Examples
#     --------
#     from mindboggle.mio.colors import distinguishable_colors
#     import numpy as np
#     ncolors = 31
#     backgrounds = [[0,0,0],[1,1,1]]
#     save_csv = False
#     plot_colormap = False
#     verbose = False
#     colors = distinguishable_colors(ncolors, backgrounds,
#     ...     save_csv, plot_colormap, verbose)
#     np.allclose(colors[0], [ 0.62068966,  0.06896552,  1.        ])
#     True
#     np.allclose(colors[1], [ 0.       ,  0.5862069,  0.       ])
#     True
#     np.allclose(colors[2], [ 0.75862069,  0.20689655,  0.        ])
#     True
#
#     import numpy as np
#     import matplotlib.pyplot as plt
#     from colormath.color_objects import LabColor, AdobeRGBColor
#     from colormath.color_conversions import convert_color
#     from colormath.color_diff import delta_e_cie2000
#     import os
#
#     filename = "colormap_of_{0}_distinguishable_colors".format(ncolors)
#     filename = os.path.join(out_dir, filename)
#
#     # ------------------------------------------------------------------------
#     # Generate a sizable number of RGB triples. This represents our space of
#     # possible choices. By starting in RGB space, we ensure that all of the
#     # colors can be generated by the monitor:
#     # ------------------------------------------------------------------------
#     n_grid = 30  # number of grid divisions along each axis in RGB space
#     x = np.linspace(0, 1, num=n_grid, endpoint=True)
#     R, G, B = np.meshgrid(x, x, x)
#     ncolors_total = np.size(R)
#     RGB = np.vstack([np.ravel(R), np.ravel(G), np.ravel(B)])
#     RGB = [[RGB[0][icolor], RGB[1][icolor], RGB[2][icolor]]
#            for icolor in range(ncolors_total)]
#     if ncolors > ncolors_total:
#         raise IOError("You can't readily distinguish that many colors")
#
#     # ------------------------------------------------------------------------
#     # Convert to Lab color space which better represents human perception:
#     # ------------------------------------------------------------------------
#     # https://python-colormath.readthedocs.io/en/latest/illuminants.html
#     lab_colors = []
#     for rgb in RGB:
#         lab = convert_color(AdobeRGBColor(rgb[0],
#                                           rgb[1],
#                                           rgb[2]), LabColor)
#         lab_colors.append(lab)
#
#     bg_lab_colors = []
#     for bg_rgb in backgrounds:
#         bg_lab = convert_color(AdobeRGBColor(bg_rgb[0],
#                                              bg_rgb[1],
#                                              bg_rgb[2]), LabColor)
#         bg_lab_colors.append(bg_lab)
#
#     # ------------------------------------------------------------------------
#     # If the user specified multiple background colors, compute differences
#     # between the candidate colors and the background colors:
#     # ------------------------------------------------------------------------
#     min_dx = np.inf * np.ones(ncolors_total)
#     if backgrounds:
#         for bg_lab_color in bg_lab_colors:
#             # Store difference from closest previously-chosen color:
#             for icolor_total, lab_color in enumerate(lab_colors):
#                 dx = delta_e_cie2000(lab_color, bg_lab_color)
#                 min_dx[icolor_total] = min(dx, min_dx[icolor_total])
#
#     # ------------------------------------------------------------------------
#     # Iteratively pick the color that maximizes the difference
#     # with the nearest already-picked color:
#     # ------------------------------------------------------------------------
#     # Initialize by making the "previous" color equal to the last background:
#     last_lab_color = bg_lab_colors[-1]
#     colors = np.zeros((ncolors, 3))
#     for icolor in range(ncolors):
#
#         # Find the difference of the last color from all colors on the list:
#         for icolor_total, lab_color in enumerate(lab_colors):
#             dx = delta_e_cie2000(lab_color, last_lab_color)
#             min_dx[icolor_total] = min(dx, min_dx[icolor_total])
#
#         # Find the entry farthest from all previously chosen colors:
#         imax_dx = np.argmax(min_dx)
#
#         # Store distant color:
#         colors[icolor] = RGB[imax_dx]
#
#         # Prepare for next iteration:
#         last_lab_color = lab_colors[imax_dx]
#
#     # ------------------------------------------------------------------------
#     # Plot the colormap as a horizontal bar chart:
#     # ------------------------------------------------------------------------
#     if plot_colormap:
#         if verbose:
#             print("RGB values:")
#         plt.figure(ncolors, figsize=(5, 10))
#         for icolor in range(ncolors):
#             ax = plt.subplot(ncolors, 1, icolor + 1)
#             plt.axis("off")
#             rgb = colors[icolor]
#             #rgb = [[rgb.rgb_r, rgb.rgb_g, rgb.rgb_b]]
#             if verbose:
#                 print(rgb)
#             plt.barh(0, 50, 1, 0, color=rgb)
#         plt.savefig(filename + ".png")
#         if verbose:
#             print("Colormap image saved to {0}".format(filename + ".png"))
#
#     # ------------------------------------------------------------------------
#     # Save the colormap as a csv file:
#     # ------------------------------------------------------------------------
#     if save_csv:
#         np.savetxt(filename + ".csv", colors, fmt='%.18e', delimiter=',',
#                    newline='\n', header='')
#         if verbose:
#             print("Colormap saved to {0}".format(filename + ".csv"))
#
#     return colors

def concentratedPolyPoleCaps(Theta, L):
    # % CONCENTRATEDPOLYNORTHPOLECAP returns the coefficients of the even
    # % polynomial optimally concentrated in the pole caps.
    # %
    # % a=CONCENTRATEDPOLYNORTHPOLECAP(Theta,L) computes for a set max bandwidth
    # % L the coefficients of the polynomial in even power terms that maximizes
    # % concentration in the north pole cap specified by the z-axis angle Theta.
    # % The basis of monomials is taken to be z^L, ...,z^2, 1 where L is
    # % assumed to be even (L-1) will be used in place of L otherwise), and so the
    # % coefficients given in the vector a will correspond to that order
    # %
    # % see POLYVAL
    #
    #     % Optimally concentrated polynomial is computed using a Rayleigh
    #     % quotient, with Cholesky decomposition of the matrix for the inner
    #     % products of the monomials (as they do not form an orthonormal basis).
    #
    #
    #     % note that until the end, the computations and the matrix
    #     % manipulations will be performed with a basis of monomials that have
    #     % are in increasing order of power, and have been normalized to have
    #     % square norm 1
    D = 2 * computeNormalizedDMatrixPoleCap(Theta, L)
    B = 2 * computeNormalizedDMatrixPoleCap(np.pi / 2, L)

    C = np.transpose(np.linalg.cholesky(np.asmatrix(B)))


    aux = np.dot(D, np.linalg.inv(C))
    M = np.dot(np.linalg.inv(np.transpose(C)), aux)

    E, V = np.linalg.eig(M)

    iMaxEigenValue = np.argmax(E)

    y = V[:, iMaxEigenValue]
    x = np.dot(np.linalg.inv(C), y)

    aux1 = range(1, len(x) + 1)
    denormVec = np.sqrt(4 * np.transpose(aux1) - 3)

    # a now gives coefficients in un-normalized standard basis z^L,
    # z^{L-2}, ..., z^2, 1 etc.
    a = np.true_divide(np.transpose(np.flipud(x)), denormVec)
    return a

def computeNormalizedDMatrixPoleCap(Theta, L):
    """COMPUTENORMALIZEDDMATRIXPOLECAP
    Get D matrix whose max eigenvector is the poles - symmetric polynomial optimally
    conccntrated at the pole caps
    D = COMPUTENORMALIZEDDMATRIXPOLECAP(THETA, L) computes for a set max bandwith
    L and pole cap with sized specified by positive z-axis angle
    THETA a matrix whose eigenvector encodes the axially symmetric even polynomial
    that is maximally concentrated on a cap around the(north) pole .The basis is
    taken to be scaled  multiples of the monomials 1, z ^ 2, z ^ 4, ..., z ^ L, where
    L is assumed  to  be even, (such that the squared norm of a basis vector over a
    half sphere is 1) and the eigenvector gives the coefficients  of the optimally
    concentrated function  written in the monomial basis above.
    That is the eigenvector is the  argmax  of the ratio:
    % int_cap  ^ 2 / int_S2 f ^ 2
    % If L is odd then  the  max bandwith  will be
    L - 1, and if that is negative an error will be thrown.The size  of the
    cap is specified by THETA, which is the angle made between the boundary of
    the cap and the positive z - axis.
    """
    # validate  THETA, L
    assert (Theta >= 0), 'ERROR: k invalid'

    L = validateBandwidth(L)

    # compute size of matrix
    N = int(L / 2 + 1)
    aux = range(1, N + 1)
    incr = np.transpose(aux)
    incrRowMat = npm.repmat(incr, N, 1)
    incrColMat = np.transpose(incrRowMat)
    # print(incrColMat)
    rowScaleMat = np.sqrt(4 * incrRowMat - 3)
    colScaleMat = np.transpose(rowScaleMat)

    # this is the denominator matrix
    denomMat = 2 * (incrRowMat + incrColMat) - 3

    # this is coincidentally the matrix for when Theta=pi / 2
    B = np.true_divide(np.multiply(rowScaleMat, colScaleMat), denomMat)

    zval = np.cos(Theta)

    capScaleMat = (1 - np.power(zval, denomMat))

    print("B = ", zval)

    D = np.multiply(B, capScaleMat)

    return D


def validateBandwidth(L):
    # perform validation for bandwidth / order L. First ensures it is even, and
    # returns error if modified version is less than 0.
    if (L % 2) != 0:
        L = L - 1

    assert (L >= 0), 'L invalid'

    return L
