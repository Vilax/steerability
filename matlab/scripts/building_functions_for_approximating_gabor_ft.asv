% script building and demonstrating functions that use steerable filters to
% approximate the fourier transform of gabor functions

% first create a fourier transform of a gabor filter
n = 100; % size of image
[X, Y] = meshgrid(-n:n);
R = sqrt(X.^2 + Y.^2);

sigma = n/6; 
y0 = n/3;
gaborEvenFT = 0.5 * (exp( -((X).^2+(Y-y0).^2)/sigma^2) + ...
                    exp(-((X).^2+(Y+y0).^2)/sigma^2));
                
figure; imagesc(gaborEvenFT);
figure; mesh(gaborEvenFT);
angle = atan2(X,Y);
Theta = angle .* (angle >= 0) - (angle .* (angle < 0));
cosTheta = cos(Theta);
                
% create function to be optimized. IE the l2 distance

fun = @(x) sum(sum((gaborEvenFT - (exp(-((R/(n/x(2))).^2) .* ...
    (polyval([x(3), x(2), 1], R)) .* ...
    (polyval([x(6), 0, x(5), 0, x(4)], cosTheta))) ).^2, 2),1)

xinit = [7, 5, 2, 2, 0.7, 1, 1.3];
options = optimset('PlotFcns',@optimplotfval);
[x, fval] = fminsearch(fun, xinit, options)
current_x = x;
current_fval = fval;


x1range = [3:8];
polyxvalrange = [0.2:0.4:3];

for idx1 = 1:numel(x1range)
    x1 = polyxvalrange(idx1);
    for idx2 = 1:numel(polyxvalrange)
        x2 = polyxvalrange(idx2);
        for idx3 = 1:numel(polyxvalrange)
            x3 = polyxvalrange(idx3);
            for idx4 = 1:numel(polyxvalrange)
                x4 = polyxvalrange(idx4);
                for idx5 = 1:numel(polyxvalrange)
                    x5 = polyxvalrange(idx5);
                    for idx6 = 1:numel(polyxvalrange)
                        x6 = polyxvalrange(idx6);
                        
                        xinit = [x1, x2, x3, x4, x5, x6];
                        [x, fval] = fminsearch(fun,xinit,options);
                        if fval < current_fval
                            current_fval = fval; 
                            current_x = x;
                        end
                    end
                end
            end
        end
    end
end
    

current_x
current_fval
                        





% NOTE: IMPLEMENT BLOCK COORDINATE DESCENT TOMORROW
